# SaaS 관점: 프록시 접근 설계

SaaS 형태 서비스에서 LLM 전략 생성 프록시에 **사용자가 어떻게 접근하는지**를 정의한다.

## 원칙: 사용자는 프록시에 직접 접근하지 않는다

- 최종 사용자(엔드유저)는 **프록시 URL·API 키를 알 수 없고, 직접 호출하지 않는다**.
- 사용자는 **SaaS 앱(웹/API)에 로그인**하고, SaaS **백엔드**가 전략 생성 시에만 프록시를 호출한다.

## 아키텍처

```
[사용자]  --로그인-->  [SaaS 웹/앱]
                            |
                            v
                     [SaaS 백엔드 API]
                     - 세션/JWT 검증
                     - 사용자·쿼터·권한 검사
                     - 전략 저장(DB)
                            |
                            v (서버 간 호출, API Key)
                     [LLM 프록시]
                     - Azure OpenAI 호출
                     - 전략 코드 생성/검증
```

## 인증·권한 역할 분리

| 계층 | 담당 | 방식 |
|------|------|------|
| **사용자 ↔ SaaS** | SaaS 백엔드 | 로그인(이메일/OAuth/Entra ID 등), 세션 또는 JWT. 사용자·테넌트 식별. |
| **SaaS 백엔드 ↔ 프록시** | 프록시 | API Key(또는 Azure M2M)로 “호출 주체 = SaaS 백엔드”만 허용. |
| **프록시 ↔ Azure OpenAI** | 프록시 | Entra ID(tenant/client/secret)로 토큰 취득 후 OpenAI 호출. |

## 프록시 접근 정책

1. **호출 허용 대상**: SaaS 백엔드만. 클라이언트(브라우저·앱)는 프록시를 직접 호출하지 않음.
2. **백엔드 → 프록시 인증**: `Authorization: Bearer <API_KEY>` 또는 `X-API-Key: <API_KEY>`. API Key는 환경변수/시크릿에만 보관.
3. **사용자 구분**: 백엔드가 요청 시 `X-User-Id` 또는 본문에 `user_id`(또는 `tenant_id`) 포함. 프록시는 로깅·쿼터·감사용으로만 사용. 실제 “이 사용자가 전략 생성 권한이 있는지”는 SaaS 백엔드에서 검증.
4. **Rate limit**: 프록시는 (선택) `user_id` 단위 또는 IP 단위로 제한. 상세 쿼터(플랜별 N회/일)는 SaaS 백엔드에서 적용 권장.

## 데이터 흐름 (전략 생성 예시)

1. 사용자가 SaaS 웹에서 “RSI 과매도 반등 전략 생성” 요청.
2. 프론트엔드가 SaaS 백엔드 `POST /api/strategies/generate` 호출 (세션 쿠키 또는 JWT 포함).
3. 백엔드: 세션/JWT 검증 → user_id 추출 → 쿼터·권한 확인 → 프록시 `POST /generate` 호출 (`X-API-Key`, `user_id` 또는 `X-User-Id` 포함, 본문에 `user_prompt`).
4. 프록시: API Key 검증 → (선택) user_id 로깅/rate limit → Azure OpenAI 호출 → 생성된 코드 반환.
5. 백엔드: 응답 받은 전략 코드를 해당 user_id(계정)에 연결해 DB/스토리지에 저장 후, 클라이언트에 결과 반환.

## 상용 확장 시

- **멀티테넌트**: 조직/팀 단위 격리는 SaaS 백엔드·DB에서 tenant_id로 처리. 프록시는 동일하게 백엔드만 신뢰.
- **플랜별 쿼터**: 백엔드에서 “이 사용자 플랜 = N회/일” 검사 후 프록시 호출 여부 결정.
- **감사**: 백엔드에서 (user_id, timestamp, prompt 요약, 전략 ID) 로깅. 프록시는 요청/에러 로그만 해도 됨.

이 설계를 따르면 SaaS에서 사용자 접근 통제와 전략 저장을 일원화하고, 프록시는 “Azure OpenAI로의 안전한 중계” 역할만 유지할 수 있다.
